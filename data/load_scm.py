import itertools
from typing import Optional, Callable, Dict

import numpy as np
import torch

import os
from load_dag import DAG, gen_dags
import torch.nn.functional as F
dirname = os.path.dirname(__file__)

####################
# Collection of synthetic datasets used in the paper.
####################


class SCM:
    """Describes the structural causal model that generates the data.
    Args:
        name (str): Name of the data generating process.
        dag (DAG): DAG structure of the SCM.
        generate_func (Callable[[int], np.ndarray]): Function that generates the data.

    Attributes:
        estimands (dict): Dictionary of estimands. Keys:
            - ``"ATE"`` (float): Average treatment effect.
            - ``"ATD"`` (float): Average treatment derivative.
        data (np.ndarray): Data generated by the SCM.
        lower_bound (Dict[int, torch.Tensor]): Lower bound dictionary for each variable.
        upper_bound (Dict[int, torch.Tensor]): Upper bound dictionary for each variable.
        diam (float): Diameter of the data.
    """
    def __init__(self, name: str, dag: DAG, generate_func: Callable[[int], np.ndarray]):
        self.name = name
        self.generate_func = generate_func
        self.dag = dag
        self.estimands = {'ATE': None, 'ATD': None}

        self.data = None
        self.lower_bound = None
        self.upper_bound = None
        self.diam = None

    def generate(self, n_samples: int) -> np.ndarray:
        data = self.generate_func(n_samples)
        diam, lower_bound, upper_bound = self._get_diam_bounds(torch.from_numpy(data), self.dag.var_dims)
        self.data = data
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound
        self.diam = diam
        return data

    @staticmethod
    def _get_diam_bounds(data: torch.Tensor, var_dims: np.ndarray):
        upper_bound, lower_bound = {}, {}
        maxx, minn = data.max(dim=0)[0], data.min(dim=0)[0]
        for i in range(var_dims.shape[0]):
            start, end = np.sum(var_dims[:i]), np.sum(var_dims[:(i + 1)])
            upper_bound[i] = torch.max(maxx[start:end], abs(minn[start:end]))
            lower_bound[i] = torch.min(minn[start:end], -abs(maxx[start:end]))
            alpha_min = 1.1 * (lower_bound[i] < 0.) + 0.9 * (lower_bound[i] >= 0.)
            alpha_max = 1.1 * (upper_bound[i] > 0.) + 0.9 * (upper_bound[i] <= 0.)
            lower_bound[i] *= alpha_min
            upper_bound[i] *= alpha_max
        diam = np.linalg.norm(data.max(dim=0)[0] - data.min(dim=0)[0])
        return diam, lower_bound, upper_bound

    def set_estimand(self, key: str, value: float):
        assert key in ['ATE', 'ATD']
        self.estimands[key] = value


def acic_2019_scm():
    def generate(n_samples: int) -> np.ndarray:
        file_path = os.path.join(dirname, './acic_2019_spam_binary_mod1.csv')
        data = np.genfromtxt(file_path, delimiter=',', skip_header=1)
        t = data[:, 1].astype(int)
        y = data[:, :1]
        # one-hot t
        t = np.eye(2)[t]
        data = np.concatenate([data[:n_samples, 2:-1], t[:n_samples], y[:n_samples]], axis=1)
        return data

    dag = gen_dags('backdoor', var_dims=np.array([22, 2, 1]), binary_keys=[1])
    path = os.path.join(dirname, './acic_2019_spam_binary_mod1.csv')
    true_ate = np.genfromtxt(path, delimiter=',', skip_header=1)[0, -1]
    scm = SCM('acic_2019', dag, generate)
    scm.set_estimand('ATE', true_ate)

    return scm


def binary_frontdoor():
    def generate(n_samples: int) -> np.ndarray:
        u1 = np.random.uniform(0, 1, size=(n_samples, 1))
        u2 = np.random.normal(0, 1, size=(n_samples, 1))
        x = np.random.binomial(1, p=u1, size=(n_samples, 1))
        w = np.random.binomial(1, p=1 / (1 + np.exp(-x - u2)), size=(n_samples, 1))
        y = np.random.binomial(1, p=1 / (1 + np.exp(w - u1)), size=(n_samples, 1))
        X = np.concatenate([x, w, y], axis=1).astype(float)
        tmp = torch.tensor(X).float()
        t = F.one_hot(tmp[:, 0].long(), num_classes=2).reshape(-1, 2)
        data = torch.cat((t, tmp[:, 1].reshape(-1, 1), tmp[:, 2].reshape(-1, 1)), dim=1).float()
        return data.numpy()

    dag = gen_dags('frontdoor', var_dims=np.array([2, 1, 1]), binary_keys=[0])
    scm = SCM('binary_frontdoor', dag, generate)
    return scm


def linear_backdoor():
    def generate(n_samples: int) -> np.ndarray:
        coeffs1 = np.array([1, -1, 2]).reshape(-1, 1)
        coeffs2 = np.array([3, 1, -0.5]).reshape(-1, 1)
        x = np.random.multivariate_normal(mean=np.array([1 for i in range(3)]), cov=np.eye(3), size=n_samples)
        t = x @ coeffs1 + 2 + np.random.normal(0, 3, size=(n_samples, 1))
        y = x @ coeffs2 + 3 * t + np.random.normal(0, 2, size=(n_samples, 1))
        data = np.concatenate([x, t, y], axis=-1)
        return data

    dag = gen_dags('backdoor', var_dims=np.array([3, 1, 1]), binary_keys=[])
    scm = SCM('linear_backdoor', dag, generate)
    scm.set_estimand('ATD', 3)
    return scm


def nonlinear_backdoor():
    def generate(n_samples: int) -> np.ndarray:
        x = np.random.normal(2, 1, size=(n_samples, 1))
        t = 0.1 * x ** 2 - x + np.random.normal(1, 2, size=(n_samples, 1))
        y = 0.5 * t ** 2 - t * x + np.random.normal(0, 2, size=(n_samples, 1))
        data = np.concatenate([x, t, y], axis=-1)
        return data

    dag = gen_dags('backdoor', var_dims=np.array([1, 1, 1]), binary_keys=[])
    scm = SCM('nonlinear_backdoor', dag, generate)
    scm.set_estimand('ATD', -2.5)
    return scm


def binary_iv():
    strata_xy = np.asarray([
        # y00         y10       y01       y11
        [0.000757, 0.013034, 0.006125, 0.002606],  # x00
        [0.004541, 0.074105, 0.034526, 0.014387],  # x10
        [0.026040, 0.418847, 0.195419, 0.082264],  # x01
        [0.004534, 0.073950, 0.034123, 0.014742]  # x11
    ])

    strata_z = [0.649335, 0.350665]

    index_dict = {
        (0, 0): [0, 2],
        (0, 1): [1, 3],
        (1, 0): [0, 1],
        (1, 1): [2, 3]
    }

    def pr(z, x, y):
        x_indices = index_dict[(z, x)]
        y_indices = index_dict[(x, y)]
        prob = 0
        for i in x_indices:
            for j in y_indices:
                prob += strata_xy[i][j]
        return strata_z[z] * (prob)

    A = np.array(list(itertools.product([0, 1], [0, 1], [0, 1])))

    def generate(n_samples: int) -> np.ndarray:
        X = A[np.random.choice(A.shape[0], size=n_samples,
                               p=[pr(z, x, y) for z, x, y in itertools.product([0, 1], [0, 1], [0, 1])])]

        tmp = torch.tensor(X).float()
        t = F.one_hot(tmp[:, 1].long(), num_classes=2).reshape(-1, 2)
        data = torch.cat((tmp[:, 0].reshape(-1, 1), t, tmp[:, 2].reshape(-1, 1)), dim=1).float()
        return data.numpy()

    dag = gen_dags('iv', var_dims=np.array([1, 2, 1]), binary_keys=[1])
    scm = SCM('binary_iv', dag, generate)
    return scm


def linear_iv():
    def generate(n_samples: int) -> np.ndarray:
        e_t = np.random.normal(0, 1, size=(n_samples, 1))
        e_y = np.random.normal(0, 1, size=(n_samples, 1))
        c = np.random.normal(0, 1, size=(n_samples, 1))
        z = np.random.multivariate_normal(np.array([-1, 0]), np.eye(2), size=n_samples)
        coeff = np.array([1, -1]).reshape(-1, 1)
        t = z @ coeff + 0.5 * c + e_t
        y = 0.5 * t - 3 * c + e_y
        data = np.concatenate([z, t, y], axis=-1)
        return data

    dag = gen_dags('iv', var_dims=np.array([2, 1, 1]), binary_keys=[])
    scm = SCM('linear_iv', dag, generate)
    scm.set_estimand('ATD', 0.5)
    return scm


def nonlinear_weak_iv():
    def generate(n_samples: int) -> np.ndarray:
        e_t = np.random.normal(0, 1, size=(n_samples, 1))
        e_y = np.random.normal(0, 1, size=(n_samples, 1))
        c = np.random.normal(0, 1, size=(n_samples, 1))
        z = np.random.multivariate_normal(np.array([-1, 0]), np.eye(2), size=n_samples)
        coeff = np.array([3, 1.5]).reshape(-1, 1)
        t = z @ coeff + 0.5 * c + e_t
        y = 0.3 * t ** 2 - 1.5 * t + c + e_y
        data = np.concatenate([z, t, y], axis=-1)
        return data

    dag = gen_dags('iv', var_dims=np.array([2, 1, 1]), binary_keys=[])
    scm = SCM('nonlinear_weak_iv', dag, generate)
    scm.set_estimand('ATD', -3.3)
    return scm


def nonlinear_strong_iv():
    def generate(n_samples: int) -> np.ndarray:
        e_t = np.random.normal(0, 1, size=(n_samples, 1))
        e_y = np.random.normal(0, 1, size=(n_samples, 1))
        c = np.random.normal(0, 1, size=(n_samples, 1))
        z = np.random.normal(0, 1, size=(n_samples, 1))
        t = 0.05 * z + 3 * c + e_t
        y = t ** 2 - 3 * t * c + e_y
        data = np.concatenate([z, t, y], axis=-1)
        return data

    dag = gen_dags('iv', var_dims=np.array([1, 1, 1]), binary_keys=[])
    scm = SCM('nonlinear_strong_iv', dag, generate)
    scm.set_estimand('ATD', 0.)
    return scm


def linear_padh_iv():
    def generate(n_samples: int) -> np.ndarray:
        e_t = np.random.normal(0, 1, size=(n_samples, 1))
        e_y = np.random.normal(0, 1, size=(n_samples, 1))
        c = np.random.normal(0, 1, size=(n_samples, 1))
        z = np.random.normal(0, 1, size=(n_samples, 1))
        t = 0.5 * z + 3 * c + e_t
        y = t - 6 * c + e_y
        data = np.concatenate([z, t, y], axis=-1)
        return data

    dag = gen_dags('iv', var_dims=np.array([1, 1, 1]), binary_keys=[])
    scm = SCM('linear_padh_iv', dag, generate)
    return scm


def nonlinear_padh_iv():
    def generate(n_samples: int) -> np.ndarray:
        e_t = np.random.normal(0, 1, size=(n_samples, 1))
        e_y = np.random.normal(0, 1, size=(n_samples, 1))
        c = np.random.normal(0, 1, size=(n_samples, 1))
        z = np.random.normal(0, 1, size=(n_samples, 1))
        t = 3 * z + 0.5 * c + e_t
        y = 0.3 * t ** 2 - 1.5 * t * c + e_y
        data = np.concatenate([z, t, y], axis=-1)
        return data

    dag = gen_dags('iv', var_dims=np.array([1, 1, 1]), binary_keys=[])
    scm = SCM('nonlinear_padh_iv', dag, generate)
    return scm


def linear_frontdoor():
    def generate(n_samples: int) -> np.ndarray:
        coeffs1 = np.array([2, -1]).reshape(-1, 1)
        coeffs2 = np.array([2, 1]).reshape(-1, 1)
        u = np.random.normal(-1, 1, size=(n_samples, 1))
        t = u + np.random.normal(0, 3, size=(n_samples, 1))
        e_x = np.random.multivariate_normal(mean=np.array([1 for i in range(2)]), cov=2 * np.eye(2), size=n_samples)
        x = t @ coeffs1.T + e_x
        y = x @ coeffs2 + u + np.random.normal(0, 2, size=(n_samples, 1))
        data = np.concatenate([t, x, y], axis=-1)
        return data

    dag = gen_dags('frontdoor', var_dims=np.array([1, 2, 1]), binary_keys=[])
    scm = SCM('linear_frontdoor', dag, generate)
    scm.set_estimand('ATD', 3)
    return scm


def nonlinear_frontdoor():
    def generate(n_samples: int) -> np.ndarray:
        u = np.random.normal(-1, 1, size=(n_samples, 1))
        t = np.random.normal(2, 2, size=(n_samples, 1)) + u
        x = 2 * t + np.random.normal(1, 2, size=(n_samples, 1))
        y = 0.25 * x ** 2 - x + u + np.random.normal(0, 2, size=(n_samples, 1))
        data = np.concatenate([t, x, y], axis=-1)
        return data

    dag = gen_dags('frontdoor', var_dims=np.array([1, 1, 1]), binary_keys=[])
    scm = SCM('nonlinear_frontdoor', dag, generate)
    scm.set_estimand('ATD', 0.)
    return scm


def leaky():
    def generate(n_samples: int) -> np.ndarray:
        u = np.random.multivariate_normal(mean=np.array([1, -1]), cov=np.eye(2), size=n_samples)
        c = np.random.normal(0, 1, size=(n_samples, 1))
        e_t = np.random.normal(0, 1, size=(n_samples, 1))
        e_y = np.random.normal(0, 1, size=(n_samples, 1))
        e_x = np.random.multivariate_normal(mean=np.array([0, 0]), cov=np.eye(2), size=n_samples)
        coeffs1 = np.array([1, 2]).reshape(-1, 1)
        coeffs2 = np.array([-1.5, 2]).reshape(-1, 1)

        t = c + e_t
        x = t @ coeffs1.T + e_x + u
        y = x @ coeffs2 + u.sum(axis=1).reshape(-1, 1) + c + e_y

        data = np.concatenate([t, x, y], axis=-1)
        return data

    dag = gen_dags('leaky', var_dims=np.array([1, 2, 1]), binary_keys=[])
    scm = SCM('leaky', dag, generate)
    scm.set_estimand('ATD', 2.5)
    return scm


def gen_scm(key: str) -> SCM:
    return {
        'linear_backdoor': linear_backdoor(),
        'nonlinear_backdoor': nonlinear_backdoor(),
        'binary_frontdoor': binary_frontdoor(),
        'linear_frontdoor': linear_frontdoor(),
        'nonlinear_frontdoor': nonlinear_frontdoor(),
        'linear_padh_iv': linear_padh_iv(),
        'nonlinear_padh_iv': nonlinear_padh_iv(),
        'linear_iv': linear_iv(),
        'binary_iv': binary_iv(),
        'nonlinear_weak_iv': nonlinear_weak_iv(),
        'nonlinear_strong_iv': nonlinear_strong_iv(),
        'leaky': leaky(),
        'acic_2019': acic_2019_scm(),
    }[key]
